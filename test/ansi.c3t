module terminal::ansi::test @test;

import glyph::font_atlas;

import std::core::string::conv;
import std::core::mem;
import std::io;

fn void no_ansi()
{
    Terminal terminal;
    terminal.init_no_external();
    defer terminal.free_no_external();

    interpret_str(terminal, "test[;;3mtest");

    GridCharFg[] correct = fg_from_array("test[;;3mtest");
    defer mem::free(correct);

    assert_fg(terminal.grid.fg, correct);
}
fn void insert_space()
{
    Terminal terminal;
    terminal.init_no_external();
    defer terminal.free_no_external();

    interpret_str(terminal, "lorem ipsu\e[6D\e[4@");

    GridCharFg[] correct = fg_from_array("lore    m ipsu");
    defer mem::free(correct);

    assert_fg(terminal.grid.fg, correct);
}
fn void cursor_updownforwardback()
{
    Terminal terminal;
    terminal.init_no_external(grid_size: 250, dimensions: { 39, 3 });
    defer terminal.free_no_external();

    interpret_str(terminal, "lorem\r\nipsum\r\nblandit\e[Aconsectetur\e[DAelit\e[BAenean\e[C\e[2Ahendrerit.");

    GridCharFg[] correct = fg_from_array("lorem                        hendrerit.ipsum  consectetuAelit                 blandit               Aenean           ");
    defer mem::free(correct);

    assert_fg(terminal.grid.fg, correct);
}
fn void cursor_newline_updown()
{
    Terminal terminal;
    terminal.init_no_external(dimensions: { 8, 5 });
    defer terminal.free_no_external();

    interpret_str(terminal, "lorem\e[3Eipsum\e[Fdolor\e[Esit\e[2Famet.con");

    GridCharFg[] correct = fg_from_array("lorem   amet.condolor   situm");
    defer mem::free(correct);

    assert_fg(terminal.grid.fg, correct);
}
fn void cursor_horizontal()
{
    Terminal terminal;
    terminal.init_no_external(dimensions: { 15, 5 });
    defer terminal.free_no_external();

    interpret_str(terminal, "lorem\e[10Gipsum\r\nsit\r\n\e[3Gdolor");

    GridCharFg[] correct = fg_from_array("lorem    ipsum sit              dolor        ");
    defer mem::free(correct);

    assert_fg(terminal.grid.fg, correct);
}

module terminal::ansi::test @private;

import glyph::font_atlas;

import std::io;

macro Terminal.init_no_external(&self, usz grid_size = 200, float font_size = 20, uint[<2>] dimensions = {20, 10}, char[<3>] bg = {}, char[<3>] fg = {0xff,0xff,0xff})
{
    self.grid = {
        .fg = mem::new_array(font_atlas::GridCharFg, grid_size),
        .bg = mem::new_array(font_atlas::GridCharBg, grid_size),
        .dimensions = dimensions,
        .fontSize = font_size,
        .size = grid_size,
    };
    defer catch { self.grid.free(); }
    self.bg = bg;
    self.fg = fg;
    for (usz i = 0; i < grid_size; i++)
    {
        self.grid.fg[i] = { ' ', self.fg };
        self.grid.bg[i].color = self.bg;
    }
    self.cursor = { .position = { 0, 0 }, .bg = self.bg, .fg = self.fg };

    self.tabs.spaces = 8;
    self.tabs.tabstopsNew.init(mem);
    self.tabs.tabstopsDel.init(mem);
}
macro Terminal.free_no_external(&self)
{
    self.grid.free();
    self.tabs.tabstopsNew.free();
    self.tabs.tabstopsDel.free();
}

macro assert_fg(fg, correct, fail = false)
{
    for (int i = 0; i < fg.len && i < correct.len; i++)
    {
        io::printfn("%d\tfg %s\tcorrect %s", i, fg[i], correct[i]);
        assert(fg[i].equals(correct[i]) || fail);
    }
    assert(!fail);
}
macro interpret_str(term, str)
{
    Char32[] buf32 = char32_from_str(str);
    defer mem::free(buf32);

    assert(@ok(term.interpret(buf32)));
}
macro char32_from_str(str)
{
    Char32[] buf32 = mem::new_array(Char32, str.len);
    buf32 = buf32[:conv::utf8to32(str, buf32)!!];
    return buf32;
}
macro GridCharFg[] fg_from_array(buf)
{
    GridCharFg[] result = mem::new_array(GridCharFg, buf.len);
    foreach (idx, &fg : result)
    {
        fg.color = {0xff,0xff,0xff};
        fg.codepoint = buf[idx];
    }
    return result;
}
