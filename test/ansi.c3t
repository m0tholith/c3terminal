module terminal::ansi @test;

import glyph::font_atlas;

import std::core::string::conv;
import std::core::mem;
import std::io;

fn void test_no_ansi()
{
    Terminal terminal;
    terminal.init_no_external();
    defer terminal.free_no_external();

    String to_interpret = "test[;;3mtest";
    Char32[] buf32 = mem::new_array(Char32, to_interpret.len);
    defer mem::free(buf32);
    buf32 = buf32[:conv::utf8to32(to_interpret, buf32)!!];

    GridCharFg[] correct = fg_from_char32(buf32);
    defer mem::free(correct);

    assert(@ok(terminal.interpret(buf32)));
    for (int i = 0; i < correct.len && i < terminal.grid.size; i++)
    {
        io::printfn("%d\tfg %s\tcorrect %s", i, terminal.grid.fg[i], correct[i]);
        assert(terminal.grid.fg[i].equals(correct[i]));
    }
}

module terminal::ansi @private;

import glyph::font_atlas;

import std::io;

macro Terminal.init_no_external(&self, usz grid_size = 200, float font_size = 20, uint[<2>] dimensions = {20, 10}, char[<3>] bg = {}, char[<3>] fg = {0xff,0xff,0xff})
{
    self.grid = {
        .fg = mem::new_array(font_atlas::GridCharFg, grid_size),
        .bg = mem::new_array(font_atlas::GridCharBg, grid_size),
        .dimensions = dimensions,
        .fontSize = font_size,
        .size = grid_size,
    };
    defer catch { self.grid.free(); }
    self.bg = bg;
    self.fg = fg;
    for (usz i = 0; i < grid_size; i++)
    {
        self.grid.fg[i] = { ' ', self.fg };
        self.grid.bg[i].color = self.bg;
    }
    self.cursor = { .position = { 0, 0 }, .bg = self.bg, .fg = self.fg };

    self.tabs.spaces = 8;
    self.tabs.tabstopsNew.init(mem);
    self.tabs.tabstopsDel.init(mem);
}
macro Terminal.free_no_external(&self)
{
    self.grid.free();
    self.tabs.tabstopsNew.free();
    self.tabs.tabstopsDel.free();
}
fn GridCharFg[] fg_from_char32(Char32[] buf)
{
    GridCharFg[] result = mem::new_array(GridCharFg, buf.len);
    foreach (idx, &fg : result)
    {
        fg.color = {0xff,0xff,0xff};
        fg.codepoint = buf[idx];
    }
    return result;
}
