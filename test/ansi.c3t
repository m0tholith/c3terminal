module terminal::ansi @test;

import glyph::font_atlas;

import std::core::string::conv;
import std::core::mem;
import std::io;

fn void test_no_ansi()
{
    Terminal terminal;
    terminal.init_no_external();
    defer terminal.free_no_external();

    String to_interpret = "test[;;3mtest";
    Char32[] buf32 = mem::new_array(Char32, to_interpret.len);
    defer mem::free(buf32);
    buf32 = buf32[:conv::utf8to32(to_interpret, buf32)!!];

    GridCharFg[] correct = fg_from_char32(buf32);
    defer mem::free(correct);

    assert(@ok(terminal.interpret(buf32)));
    assert_fg(terminal.grid.fg, correct);
}
fn void test_insert_space()
{
    Terminal terminal;
    terminal.init_no_external();
    io::printfn("terminal fg: %p", terminal.grid.fg.ptr);
    defer terminal.free_no_external();

    interpret_str(terminal, "lorem ipsu\e[6D\e[4@");

    String correct_str = "lore    m ipsu";
    Char32[] correct_32 = mem::new_array(Char32, correct_str.len);
    defer mem::free(correct_32);
    correct_32 = correct_32[:conv::utf8to32(correct_str, correct_32)!!];
    GridCharFg[] correct = fg_from_char32(correct_32);
    defer mem::free(correct);

    assert_fg(terminal.grid.fg, correct);
}
fn void test_cursor_updownforwardback()
{
    Terminal terminal;
    terminal.init_no_external(grid_size: 250, dimensions: { 39, 3 });
    defer terminal.free_no_external();

    interpret_str(terminal, "lorem\r\nipsum\r\nblandit\e[Aconsectetur\e[DAelit\e[BAenean\e[C\e[2Ahendrerit.");

    String correct_str = "lorem                        hendrerit.ipsum  consectetuAelit                 blandit               Aenean           ";
    Char32[] correct_32 = mem::new_array(Char32, correct_str.len);
    defer mem::free(correct_32);
    correct_32 = correct_32[:conv::utf8to32(correct_str, correct_32)!!];
    GridCharFg[] correct = fg_from_char32(correct_32);
    defer mem::free(correct);

    assert_fg(terminal.grid.fg, correct);
}

module terminal::ansi @private;

import glyph::font_atlas;

import std::io;

macro Terminal.init_no_external(&self, usz grid_size = 200, float font_size = 20, uint[<2>] dimensions = {20, 10}, char[<3>] bg = {}, char[<3>] fg = {0xff,0xff,0xff})
{
    self.grid = {
        .fg = mem::new_array(font_atlas::GridCharFg, grid_size),
        .bg = mem::new_array(font_atlas::GridCharBg, grid_size),
        .dimensions = dimensions,
        .fontSize = font_size,
        .size = grid_size,
    };
    defer catch { self.grid.free(); }
    self.bg = bg;
    self.fg = fg;
    for (usz i = 0; i < grid_size; i++)
    {
        self.grid.fg[i] = { ' ', self.fg };
        self.grid.bg[i].color = self.bg;
    }
    self.cursor = { .position = { 0, 0 }, .bg = self.bg, .fg = self.fg };

    self.tabs.spaces = 8;
    self.tabs.tabstopsNew.init(mem);
    self.tabs.tabstopsDel.init(mem);
}
macro Terminal.free_no_external(&self)
{
    self.grid.free();
    self.tabs.tabstopsNew.free();
    self.tabs.tabstopsDel.free();
}

macro assert_fg(fg, correct)
{
    for (int i = 0; i < fg.len && i < correct.len; i++)
    {
        io::printfn("%d\tfg %s\tcorrect %s", i, fg[i], correct[i]);
        assert(fg[i].equals(correct[i]));
    }
}
macro interpret_str(term, str)
{
    Char32[] buf32 = mem::new_array(Char32, str.len);
    buf32 = buf32[:conv::utf8to32(str, buf32)!!];
    defer mem::free(buf32);

    assert(@ok(term.interpret(buf32)));
}
fn GridCharFg[] fg_from_char32(Char32[] buf)
{
    GridCharFg[] result = mem::new_array(GridCharFg, buf.len);
    foreach (idx, &fg : result)
    {
        fg.color = {0xff,0xff,0xff};
        fg.codepoint = buf[idx];
    }
    return result;
}
